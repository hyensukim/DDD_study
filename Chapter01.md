# 🎆 도메인 모델 시작하기

> 핵심 학습 목표

✅ 도메인

✅ 도메인 모델

✅ 엔티티와 벨류

✅ 도메인 용어

## 1.1 도메인이란?

도메인은 '온라인 서점 소프트웨어'와 같이 사업적 목적에 의해 구현된 프로그램을 의미한다.

한도메인은 여러 개의 도메인으로 나뉘는데, 온라인 서점 소프트웨어를 예로 들면,

![img](https://raw.githubusercontent.com/hyensukim/DDD_study/main/image/%ED%95%98%EC%9C%84%20%EB%8F%84%EB%A9%94%EC%9D%B8%20%EC%98%88%EC%8B%9C.png)

위와 같이 온라인 서점이라는 소프트웨어는 주문을 처리하기 위한 '주문' 도메인, 금액 정산을 처리하기 위한 '정산' 도메인 등의 하위 도메인으로 나뉜다.

특정 도메인을 위한 소프트웨어라고 해서 도메인이 제공할 모든 기능을 직접 구현하는 것은 아니다.

![img](https://raw.githubusercontent.com/hyensukim/DDD_study/main/image/%EC%99%B8%EB%B6%80%EC%97%90%20%EA%B8%B0%EB%8A%A5%EC%9D%84%20%EB%A7%A1%EA%B8%B0%EB%8A%94%20%EC%98%88%EC%8B%9C.png)

즉, 특정 기능은 외부 업체의 기능을 사용하여 처리한다.

하위 도메인의 구성 여부는 상황에 따라 바뀐다.

예를 들어, 기업을 대상으로 하는 쇼핑몰은 마일리지나 배송 추적과 같은 기능을 제공할 필요가 없지만, 개인 고객을 대상으로 하는 쇼핑몰은 필요하다.

> ✅ 도메인

- 목적을 수행하기 위해 구현된 소프트웨어.
- 하위 도메인을 가진다.
- 모든 하위 도메인을 직접 구현하지는 않는다.
- 하위 도메인의 구성은 상황에 따라 다르다.

## 1.2 도메인 전문가와 개발자 간 지식 공유

도메인을 구현 시 어떠한 요구사항에 맞게 구현하는 것이 중요하다.

그러기 위해서는 개발자가 요구사항을 올바르게 이해해야 한다.

이를 위한 방법 중 하나가 도메인 전문가와 소프트웨어 개발자가 직접 대화하는 것이다.

도메인 전문가는 도메인을 사용 시 필요한 요구사항을 건의하고, 해당 내용을 올바르게 이해한 뒤 구현하게 되면 목적에 알맞은 소프트웨어 개발이 가능하다.

## 1.3 도메인 모델

도메인 모델은 기본적으로 특정 도메인을 개념적으로 표현한 것을 의미한다.

도메인을 쉽게 이해하게 그리는 관계도, 그림 정도로 이해하자.

예를 들어, '주문 도메인'을 이해하기 위해 하위 도메인로 구성된 개념(추상) 모델을 참조한다.

![객체를 이용한 도메인 모델]()

위 같은 경우, 정확하게는 몰라도 해당 도메인에서 주문정보 수정, 주문 취소 등의 기능을 할 수 있다는 것을 알 수 있다.

이것 외에도 필요에 따라 이해하기 쉬운 형태의 다양한 도메인 모델링이 가능하다.

이러한 추상적인 관계도를 바로 코드로 옮기라고 한다면 힘들것이다.

도메인 모델 과 구현 코드 사이에 구현 모델이라는 중간 단계를 거쳐 코드로 작성한다.

☢️ 하나 주의할 점이 있다면, 하위 도메인의 의미가 모호한 경우에 즉, 다른 도메인에도 동일한 이름의 하위의 도메인이 존재하는 경우에 이 두 도메인은 분리하여 모델링 해줘야 한다.(결국, 코드로 옮길 때 이해가 쉽도록 하기 위함)

✅ 도메인 모델

- 도메인 모델은 도메인을 이해하기 위해 작성한 `개념 모델`이다.

## 1.4 도메인 모델 패턴

![애플리케이션 아키텍처]()

도메인 계층은 도메인 핵심 규칙을 객체지향적으로 구현한 객체이다.

핵심 규칙을 구현한 코드를 도메인 모델 안에 위치하도록 응집력을 높이면, 이를 확장하거나 수정 시 다른 코드에 영향을 비교적 덜 주게 된다.

위에서 언급한 `도메인 모델`은 도메인 계층 구현 시 사용하는 객체 모델을 의미한다.

## 1.5 도메인 모델 도출

도메인 계층을 코드로 구현하기 위해서는 도메인 모델링이 필연적이다.

도메인 모델링의 기본은 핵심 구성요소, 규칙, 기능 등을 찾는 과정이며, 이것의 시작은 요구사항에서 시작한다.

### 도메인 모델 도출 과정(예시 : 주문 도메인)

주문 도메인 관련 요구사항을 예로 들겠다.

- 최소 한 종류 이상의 상품을 주문해야 한다.
- 한 상품을 한 개 이상 주문이 할 수 있다.
- 총 주문 금액은 각 상품의 구매 가격 합을 모두 더한 금액이다.
- 각 상품의 구매 가격 합은 상품 가격에 구매 개수를 곱한 값이다.
- 주문할 때 배송지 정보를 반드시 지정해야 한다.
- 배송지 정보는 받는 사람 이름, 전화번호, 주소로 구성된다.
- 출고 이후에 배송지 변경을 할 수 없다.
- 출고 전까지 주문 취소가 가능하다.
- 고객이 결제를 완료하기 전에는 상품을 준비하지 않는다.

위 요구 사항에서 주문에 예상되는 기능들은

주문 취소하기, 결제 완료, 출고 상태 변경하기, 배송지 정보 변경하기 이다.

## 1.6 엔티티와 밸류

도메인 모델은 크게 엔티티(Entity)와 밸류(Value)로 구분이 가능하다.

### 1.6.1 엔티티

엔티티의 가장 큰 특징은 객체마다 고유의 식별자를 갖는 것이다.

엔티티의 식별자는 고유하기 때문에 두 엔티티 객체의 식별자가 같으면 두 엔티티는 같다고 판단할 수 있다.


### 1.6.2 엔티티의 식별자 생성

엔티티의 식별자를 생성하는 시점은 도메인의 특징과 사용하는 기술에 따라 달라진다.

- 특정 규칙에 따라 생성
- UUID 또는 Nano ID와 같은 고유 식별자 생성기 사용
- 값을 직접 입력
- 일련번호 사용(시퀀스나 DB의 자동 증가 컬럼 사용)

특정 규칙에 따라 생성되는 식별자는 각 회사마다 규칙이 다르다. 일반적으로 사용하는 방식이 현재 시간과 다른 특정한 값을 조합하는 형태이다.

UUID를 사용한 식별자를 생성하는 방법도 있다. 다수의 언어에서 제공하는 UUID를 사용하면 된다. 예를 들면,  자바의 java.util.UUID도 있다.

회원의 아이디 또는 이메일은 회원이 직접 입력하기 때문에 입력값이 중복되지 않는지 확인해줘야 한다.

일련번호 방식은 주로 DBMS에서 제공하는 자동 증가 기능을 사용하는 경우가 많다.


### 1.6.3 밸류타입

```
public class ShippingInfo{
	// 받는 사람
	private String receiverName;
	private String receivrPhoneNumber;

	//주소
	private String shippingAddress1;
	private String shippingAddress2;
	private String shippingZipcode;
}
```

위에 receiverName 필드와 receiverPhoneNumber 필드는 서로 다른 데이터를 담고 있지만, 개념적으로 동일한 개념을 표현한다. 즉, 받는 사람의 정보를 의미한다. 주소 데이터를 갖는 필드도 마찬가지로 주소라는 개념 하나로 표현이 가능하다.

즉, 밸류 타입이란 개념적으로 완전한 하나를 표현할 때 사용한다.

밸류 타입이 꼭 두 개 이상의 데이터를 가져야 하는 것은 아니다. 의미를 명확하게 표현하기 위한 경우에도 사용한다.

```
주문 항목 도메인
public class OrderLine{
	private Product product;
	private int price;
	private int quantity;
	private int amounts;
}

-->

public class OrderLine{
	private Product product;
	private Money price;
	private int quantity;
	private Money amounts;
}

```

위에 코드에서 price와 amounts는 int 형의 숫자지만, '돈' 이라는 개념으로 생각하면 동일한 개념이다. 따라서 Money라는 밸류 타입을 만들어 사용하면 코드의 의미를 명확하게 표현할 수 있게 된다.

밸류 타입의 또다른 장점은 밸류 객체를 위한 기능 추가가 가능하다는 것이다.

밸류 객체의 데이터 변경 시에는 기존의 데이터를 바꾸기 보다는 새로운 객체를 생성하여 값을 변경해주는 방식을 선호한다.

```
public class Money{
	private int value;
	... 생성자, getValue()

	public Money add(Money money){
		return new Money(this.value + money.value);
	}
}
```

위에 코드를 보면, add(Money money) 메서드로 새로운 Money객체를 반환 해준다.

위처럼 하는 이유는 기존의 데이터 불변(immutable)을 통해 ***참조 투명성***과 ***스레드에 안전한*** 코드를 작성할 수 있기 때문이다.

❓ 참조 투명성...?


### 1.6.4 엔티티 식별자와 밸류 타입

주문 엔티티 식별자의 필드명을 id라고 지정한 경우, 실제 해당 필드가 주문번호를 의미하는 지 정확히 알 수 없게 되므로, OrderNo 라는 밸류 객체를 생성하여 String 대신에 OrderNo 타입으로 선언해주면, 선언부만 봐도 명확한 의미를 표현할 수 있다.


### 1.6.5 도메인 모델에 set 메서드 넣지 않기

## 1.7 도메인 용어와 유비쿼터스 언어
